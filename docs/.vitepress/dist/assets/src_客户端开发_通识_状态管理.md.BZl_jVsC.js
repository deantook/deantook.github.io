import{_ as l,c as e,o as r,af as a}from"./chunks/framework.Dxic3Z6b.js";const c=JSON.parse('{"title":"📖 客户端开发通识：状态管理","description":"","frontmatter":{},"headers":[],"relativePath":"src/客户端开发/通识/状态管理.md","filePath":"src/客户端开发/通识/状态管理.md"}'),i={name:"src/客户端开发/通识/状态管理.md"};function o(d,t,s,n,h,p){return r(),e("div",null,[...t[0]||(t[0]=[a('<p>明白，我们继续讲 <strong>客户端状态管理（与服务端 stateless 对比）</strong>，这是理解 Flutter 状态管理的关键前置知识。</p><h1 id="📖-客户端开发通识-状态管理" tabindex="-1">📖 客户端开发通识：状态管理 <a class="header-anchor" href="#📖-客户端开发通识-状态管理" aria-label="Permalink to “📖 客户端开发通识：状态管理”">​</a></h1><h2 id="_1️⃣-什么是状态-state" tabindex="-1">1️⃣ 什么是状态（State） <a class="header-anchor" href="#_1️⃣-什么是状态-state" aria-label="Permalink to “1️⃣ 什么是状态（State）”">​</a></h2><ul><li><p><strong>状态</strong>：描述界面在某一时刻的“数据快照”或“内部信息”。</p></li><li><p><strong>客户端状态特点</strong>：</p><ol><li><strong>动态性</strong>：用户操作、网络请求、动画等会改变状态</li><li><strong>与 UI 强绑定</strong>：状态变化直接影响界面渲染</li><li><strong>生命周期相关</strong>：状态存在于页面生命周期内（或全局）</li></ol></li></ul><h2 id="_2️⃣-客户端状态-vs-服务端状态" tabindex="-1">2️⃣ 客户端状态 vs 服务端状态 <a class="header-anchor" href="#_2️⃣-客户端状态-vs-服务端状态" aria-label="Permalink to “2️⃣ 客户端状态 vs 服务端状态”">​</a></h2><table tabindex="0"><thead><tr><th>特性</th><th>服务端状态</th><th>客户端状态</th></tr></thead><tbody><tr><td>生命周期</td><td>请求处理期间，通常无状态（stateless）</td><td>页面/应用生命周期内，持续存在</td></tr><tr><td>数据存储</td><td>数据库、缓存、会话</td><td>内存、数据库、本地存储</td></tr><tr><td>更新方式</td><td>每次请求重新生成</td><td>用户操作、异步回调动态更新 UI</td></tr><tr><td>UI 绑定</td><td>无直接绑定</td><td>状态变化 → UI 自动刷新（响应式）</td></tr></tbody></table><p>💡 <strong>理解</strong>：</p><ul><li>服务端多是 <strong>stateless</strong>（请求独立），客户端多是 <strong>stateful</strong>（状态驱动 UI）。</li><li>这也是 Flutter 强调 <strong>声明式 UI + 状态管理</strong> 的原因：状态变化就渲染 UI，不用手动操作 DOM 或控件。</li></ul><h2 id="_3️⃣-状态类型" tabindex="-1">3️⃣ 状态类型 <a class="header-anchor" href="#_3️⃣-状态类型" aria-label="Permalink to “3️⃣ 状态类型”">​</a></h2><ol><li><p><strong>局部状态（Local State）</strong></p><ul><li>页面或组件内部状态，只影响当前 Widget</li><li>Flutter 对应：<code>setState</code>、<code>StatefulWidget</code> 内部变量</li></ul></li><li><p><strong>全局状态（Global / App State）</strong></p><ul><li>跨页面共享的状态，例如登录信息、购物车数据</li><li>Flutter 对应：Provider、Riverpod、Bloc 等状态管理框架</li></ul></li><li><p><strong>瞬态状态（Ephemeral State）</strong></p><ul><li>临时状态，如按钮点击、弹窗显示</li><li>生命周期短，通常局部管理即可</li></ul></li><li><p><strong>持久化状态（Persistent State）</strong></p><ul><li>跨 App 重启保留，如用户设置、缓存数据</li><li>Flutter 对应：<code>shared_preferences</code>、<code>sqflite</code>、<code>hive</code></li></ul></li></ol><h2 id="_4️⃣-客户端状态管理核心原则" tabindex="-1">4️⃣ 客户端状态管理核心原则 <a class="header-anchor" href="#_4️⃣-客户端状态管理核心原则" aria-label="Permalink to “4️⃣ 客户端状态管理核心原则”">​</a></h2><ol><li><p><strong>单向数据流</strong>（Unidirectional Data Flow）</p><ul><li>状态改变 → UI 渲染 → 用户操作 → 状态改变</li><li>避免双向绑定造成的混乱</li></ul></li><li><p><strong>状态与 UI 分离</strong></p><ul><li>页面逻辑独立于 UI，便于维护和测试</li></ul></li><li><p><strong>响应式更新</strong></p><ul><li>状态改变触发 UI 自动刷新，无需手动刷新控件</li></ul></li><li><p><strong>生命周期感知</strong></p><ul><li>避免在页面销毁后仍然更新状态或触发异步任务</li><li>Flutter 对应：<code>dispose</code>、<code>mounted</code> 检查</li></ul></li></ol><h2 id="_5️⃣-服务端工程师类比" tabindex="-1">5️⃣ 服务端工程师类比 <a class="header-anchor" href="#_5️⃣-服务端工程师类比" aria-label="Permalink to “5️⃣ 服务端工程师类比”">​</a></h2><table tabindex="0"><thead><tr><th>客户端概念</th><th>服务端类比</th></tr></thead><tbody><tr><td>局部状态</td><td>方法内局部变量</td></tr><tr><td>全局状态</td><td>缓存 / 会话数据（如 Redis、Session）</td></tr><tr><td>响应式 UI</td><td>请求响应自动渲染 HTML / JSON</td></tr><tr><td>生命周期管理</td><td>请求上下文管理、资源释放</td></tr></tbody></table><p>💡 <strong>核心启示</strong>：</p><ul><li>客户端状态管理的核心就是 <strong>数据驱动 UI</strong>，与服务端请求-响应模型有类比但更强调 <strong>动态交互和生命周期</strong>。</li><li>Flutter 的 Widget + State 模型正是将状态和 UI 解耦，同时结合事件循环和渲染机制实现高性能界面更新。</li></ul><p>接下来，你可以继续深入 <strong>本地存储方式（KV 存储、SQLite、文件系统）</strong>，它是状态管理的持久化实现，也是客户端开发的重要通识知识。</p><p>我可以直接帮你讲本地存储。</p>',18)])])}const u=l(i,[["render",o]]);export{c as __pageData,u as default};
