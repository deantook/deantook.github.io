import{_ as i,c as t,o as a,ah as r}from"./chunks/framework.D3s0AgZG.js";const p=JSON.parse('{"title":"🌐 各端原生开发前世今生","description":"","frontmatter":{},"headers":[],"relativePath":"src/客户端开发/客户端开发概述/原生开发/前世今生.md","filePath":"src/客户端开发/客户端开发概述/原生开发/前世今生.md"}'),e={name:"src/客户端开发/客户端开发概述/原生开发/前世今生.md"};function o(n,l,d,s,h,u){return a(),t("div",null,[...l[0]||(l[0]=[r('<h1 id="🌐-各端原生开发前世今生" tabindex="-1">🌐 各端原生开发前世今生 <a class="header-anchor" href="#🌐-各端原生开发前世今生" aria-label="Permalink to “🌐 各端原生开发前世今生”">​</a></h1><h2 id="_1️⃣-windows-原生开发" tabindex="-1">1️⃣ Windows 原生开发 <a class="header-anchor" href="#_1️⃣-windows-原生开发" aria-label="Permalink to “1️⃣ Windows 原生开发”">​</a></h2><h3 id="前世" tabindex="-1">前世 <a class="header-anchor" href="#前世" aria-label="Permalink to “前世”">​</a></h3><ul><li><p><strong>早期</strong>：DOS 时代，主要靠命令行。</p></li><li><p><strong>Windows 3.x</strong>：</p><ul><li>GUI 出现，Win32 API 初步实现。</li></ul></li><li><p><strong>Windows 95/98/NT</strong>：</p><ul><li>Win32 API 成熟，开发语言主要是 <strong>C / C++</strong>。</li><li>MFC（Microsoft Foundation Class）封装 Win32，简化 GUI 开发。</li></ul></li><li><p><strong>Visual Basic</strong>：</p><ul><li>1991 年诞生，快速开发 GUI，流行于企业应用。</li></ul></li></ul><h3 id="今生" tabindex="-1">今生 <a class="header-anchor" href="#今生" aria-label="Permalink to “今生”">​</a></h3><ul><li><p><strong>现代 Windows</strong>：</p><ul><li>支持 <strong>UWP（Universal Windows Platform）</strong> 和 <strong>WinUI 3</strong>。</li><li>开发语言：C#, C++, Rust（逐渐流行）。</li><li>目标：一次开发，可在 PC、Surface 等设备运行。</li></ul></li><li><p><strong>趋势</strong>：</p><ul><li>WinUI + XAML 宣告式 UI 趋势。</li><li>Flutter / Electron 等跨平台框架逐渐补充原生生态。</li></ul></li></ul><h2 id="_2️⃣-macos-原生开发" tabindex="-1">2️⃣ macOS 原生开发 <a class="header-anchor" href="#_2️⃣-macos-原生开发" aria-label="Permalink to “2️⃣ macOS 原生开发”">​</a></h2><h3 id="前世-1" tabindex="-1">前世 <a class="header-anchor" href="#前世-1" aria-label="Permalink to “前世”">​</a></h3><ul><li><p><strong>Classic Mac OS（1984–2001）</strong></p><ul><li>系统基于 <strong>Mac Toolbox API</strong>。</li><li>开发语言：Pascal、C。</li><li>界面事件驱动，早期没有多任务。</li></ul></li></ul><h3 id="今生-1" tabindex="-1">今生 <a class="header-anchor" href="#今生-1" aria-label="Permalink to “今生”">​</a></h3><ul><li><p><strong>macOS（OS X 2001 之后）</strong></p><ul><li>Cocoa 框架（Objective-C）。</li><li>Swift 2014 推出，现代化语言。</li><li>UI 通过 <strong>AppKit</strong> 构建。</li><li>生命周期和事件响应模式类似 iOS。</li></ul></li><li><p><strong>趋势</strong></p><ul><li>宣告式 UI：SwiftUI。</li><li>对 Flutter 支持良好，原生渲染。</li></ul></li></ul><h2 id="_3️⃣-linux-原生开发" tabindex="-1">3️⃣ Linux 原生开发 <a class="header-anchor" href="#_3️⃣-linux-原生开发" aria-label="Permalink to “3️⃣ Linux 原生开发”">​</a></h2><h3 id="前世-2" tabindex="-1">前世 <a class="header-anchor" href="#前世-2" aria-label="Permalink to “前世”">​</a></h3><ul><li><p><strong>早期 Linux</strong>：</p><ul><li>X11 + GTK / Qt 构建 GUI。</li><li>开发语言：C、C++。</li><li>面向服务器和桌面，桌面占比低。</li></ul></li></ul><h3 id="今生-2" tabindex="-1">今生 <a class="header-anchor" href="#今生-2" aria-label="Permalink to “今生”">​</a></h3><ul><li><p><strong>现代 Linux 桌面</strong>：</p><ul><li>GNOME、KDE 框架成熟。</li><li>支持 GTK / Qt / Rust + egui / Flutter Desktop。</li></ul></li><li><p><strong>趋势</strong></p><ul><li>轻量、跨平台，原生 GUI 趋向“可选”。</li><li>Flutter / Electron / Rust GUI 逐渐流行。</li></ul></li></ul><h2 id="_4️⃣-android-原生开发" tabindex="-1">4️⃣ Android 原生开发 <a class="header-anchor" href="#_4️⃣-android-原生开发" aria-label="Permalink to “4️⃣ Android 原生开发”">​</a></h2><h3 id="前世-3" tabindex="-1">前世 <a class="header-anchor" href="#前世-3" aria-label="Permalink to “前世”">​</a></h3><ul><li><p><strong>初期（2008–2011）</strong></p><ul><li>Java + Android SDK。</li><li>应用以 Activity / Service 为核心。</li></ul></li><li><p><strong>Kotlin 推出（2017）</strong></p><ul><li>官方推荐语言。</li><li>更安全、更简洁。</li></ul></li><li><p><strong>原生 UI</strong></p><ul><li>XML 布局 + 事件回调。</li><li>Fragment + RecyclerView 构建复杂页面。</li></ul></li></ul><h3 id="今生-3" tabindex="-1">今生 <a class="header-anchor" href="#今生-3" aria-label="Permalink to “今生”">​</a></h3><ul><li><p><strong>现代 Android</strong></p><ul><li>Jetpack 架构（ViewModel, LiveData, Navigation）。</li><li>Kotlin + 协程 + Flow。</li><li>宣告式 UI：Jetpack Compose，理念类似 Flutter。</li></ul></li><li><p><strong>趋势</strong></p><ul><li>轻量、可组合、响应式 UI。</li><li>Flutter 直接替代原生 UI 层成为可选方案。</li></ul></li></ul><h2 id="_5️⃣-ios-原生开发" tabindex="-1">5️⃣ iOS 原生开发 <a class="header-anchor" href="#_5️⃣-ios-原生开发" aria-label="Permalink to “5️⃣ iOS 原生开发”">​</a></h2><h3 id="前世-4" tabindex="-1">前世 <a class="header-anchor" href="#前世-4" aria-label="Permalink to “前世”">​</a></h3><ul><li><p><strong>初期（2007–2010）</strong></p><ul><li>Objective-C + Cocoa Touch。</li><li>UIKit + Storyboard 组合构建界面。</li></ul></li><li><p><strong>Swift 推出（2014）</strong></p><ul><li>更安全、更简洁。</li><li>与 Objective-C 互操作。</li></ul></li></ul><h3 id="今生-4" tabindex="-1">今生 <a class="header-anchor" href="#今生-4" aria-label="Permalink to “今生”">​</a></h3><ul><li><p><strong>现代 iOS</strong></p><ul><li>Swift + SwiftUI（宣告式 UI）。</li><li>Combine 框架实现响应式编程。</li><li>全面支持 iPadOS、watchOS、tvOS。</li></ul></li><li><p><strong>趋势</strong></p><ul><li>SwiftUI + Combine 让界面开发更类似 Flutter。</li><li>Flutter 直接可以渲染 iOS 原生控件。</li></ul></li></ul><h2 id="_6️⃣-小结对比" tabindex="-1">6️⃣ 小结对比 <a class="header-anchor" href="#_6️⃣-小结对比" aria-label="Permalink to “6️⃣ 小结对比”">​</a></h2><table tabindex="0"><thead><tr><th>平台</th><th>传统语言</th><th>UI 框架</th><th>现代趋势</th><th>Flutter 对应</th></tr></thead><tbody><tr><td>Windows</td><td>C/C++/C#</td><td>Win32/MFC/UWP</td><td>宣告式 UI（WinUI）</td><td>Flutter Desktop</td></tr><tr><td>macOS</td><td>Objective-C/Swift</td><td>Cocoa/AppKit</td><td>SwiftUI</td><td>Flutter Desktop</td></tr><tr><td>Linux</td><td>C/C++</td><td>GTK/Qt</td><td>Rust + egui / Flutter</td><td>Flutter Desktop</td></tr><tr><td>Android</td><td>Java/Kotlin</td><td>XML + View</td><td>Jetpack Compose</td><td>Flutter Android</td></tr><tr><td>iOS</td><td>Objective-C/Swift</td><td>UIKit</td><td>SwiftUI + Combine</td><td>Flutter iOS</td></tr></tbody></table><p>💡 <strong>核心启示</strong>：</p><ol><li>所有平台都在向 <strong>宣告式 UI + 响应式状态管理</strong> 演进。</li><li>Flutter 的 Widget + State 模型可以理解为跨平台实现了这个趋势。</li><li>服务端工程师切入 Flutter 可以不用纠结各端 API，而专注于业务逻辑 + UI 组合。</li></ol>',30)])])}const g=i(e,[["render",o]]);export{p as __pageData,g as default};
